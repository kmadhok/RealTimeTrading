# -*- coding: utf-8 -*-
"""Trade_Logic_Client (updated).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LgL8_qy-rruiCWnnJ-TOlVFMWmGNRO5e
"""

import requests
import json
import time
import pandas as pd
import numpy as np

# def handle_data(data):
#     print("Data received:", data)

# def stream_data():
#     with open('data.json', 'r') as file:
#         for line in file:
#             data = json.loads(line)
#             handle_data(data)
#             time.sleep(1)

# def receive_stream():
#     response = requests.get('http://localhost:5000/stream', stream=True)
#     for line in response.iter_lines():
#         if line:
#             decoded_line = line.decode('utf-8')
#             print(decoded_line)

# if __name__ == '__main__':
#     receive_stream()
# Create a new DataFrame with only the columns needed for twitter_signals
# twitter_signals_df = original_data[['close', 'strong_positive']].copy()

# # Assuming the rows represent sequential time periods, add a time index (e.g., days)
# # If you have actual dates, use them instead of this index.
# twitter_signals_df['time'] = pd.date_range(start='2023-01-01', periods=len(twitter_signals_df), freq='D')

# # Reordering the columns for clarity
# twitter_signals_df = twitter_signals_df[['time', 'close', 'strong_positive']]

# # Show the new DataFrame
# print(twitter_signals_df)
path='/Users/kanumadhok/Desktop/Desktop Kanu/UChicago/Class/Real TIme/Final_Project/NewExample/trade_data.csv'
df=pd.read_csv(path)


def calculate_moving_average(data, window_size):
    return data.rolling(window=window_size).mean()

def evaluate_signals(data, twitter_signals):
    short_term_ma = calculate_moving_average(data['close'], 10)  # Short-term moving average
    long_term_ma = calculate_moving_average(data['close'], 50)  # Long-term moving average
    signals = []

    for i in range(len(data)):
        # Buy signal: Short-term MA > Long-term MA AND positive Twitter sentiment
        if short_term_ma[i] > long_term_ma[i] and twitter_signals[i] == 1:
            signals.append(1)  # Signal to buy
        # Sell signal: Short-term MA < Long-term MA OR neutral Twitter sentiment
        elif short_term_ma[i] < long_term_ma[i] and twitter_signals[i] != 1:
            signals.append(-1)  # Signal to sell
        else:
            signals.append(0)  # No action / hold

    return signals

def execute_strategy_live(data, twitter_signals, initial_capital=1000000.0):
    # Evaluate signals based on moving averages and Twitter sentiment
    signals = evaluate_signals(data, twitter_signals)

    # Initialize live positions DataFrame
    live_positions = pd.DataFrame(index=data.index, columns=['live_cash', 'live_BTC'])
    live_positions['live_cash'] = initial_capital
    live_positions['live_BTC'] = 0

    for i in range(1, len(signals)):
        # Execute buy order if signal is 1 and there's enough cash
        if signals[i] == 1 and live_positions['live_cash'][i-1] >= data['close'][i]:
            order = execute_order(symbol='BTCUSD', qty=1, side='buy', order_type='market')
            if order:
                live_positions['live_BTC'][i] = live_positions['live_BTC'][i-1] + 1
                live_positions['live_cash'][i] = live_positions['live_cash'][i-1] - data['close'][i]
        # Execute sell order if signal is -1 and there's BTC to sell
        elif signals[i] == -1 and live_positions['live_BTC'][i-1] > 0:
            order = execute_order(symbol='BTCUSD', qty=1, side='sell', order_type='market')
            if order:
                live_positions['live_BTC'][i] = live_positions['live_BTC'][i-1] - 1
                live_positions['live_cash'][i] = live_positions['live_cash'][i-1] + data['close'][i]
        # No action (hold) if signal is 0 or conditions to buy/sell are not met
        else:
            live_positions['live_BTC'][i] = live_positions['live_BTC'][i-1]
            live_positions['live_cash'][i] = live_positions['live_cash'][i-1]

    # Calculate live portfolio value
    live_portfolio = live_positions.copy()
    live_portfolio['live_holdings'] = live_portfolio['live_BTC'] * data['close']
    live_portfolio['live_total'] = live_portfolio['live_cash'] + live_portfolio['live_holdings']

    return live_portfolio

df_btc=df.copy()
signals = df_btc['strong_positive']

# Example usage:
live_portfolio = execute_strategy_live(df_btc, signals)
#live_portfolio = execute_strategy_live(signals, df_btc)

print(live_portfolio)

# def place_order(order_type, quantity, symbol):
#     # Prepare order data
#     order_data = {
#         'type': order_type,
#         'quantity': quantity,
#         'symbol': symbol
#     }

#     # Send order request to the server
#     response = requests.post('http://localhost:5000/place_order', json=order_data)

#     # Handle response
#     if response.status_code == 200:
#         print('Order placed successfully:', response.json())
#     else:
#         print('Error placing order:', response.text)



